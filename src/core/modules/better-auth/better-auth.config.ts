import { passkey } from '@better-auth/passkey';
import { Logger } from '@nestjs/common';
import { betterAuth, BetterAuthPlugin } from 'better-auth';
import { mongodbAdapter } from 'better-auth/adapters/mongodb';
import { jwt, twoFactor } from 'better-auth/plugins';
import * as crypto from 'crypto';

import { IBetterAuth, IBetterAuthSocialProvider } from '../../common/interfaces/server-options.interface';

/**
 * Type for better-auth instance with plugins
 */
export type BetterAuthInstance = ReturnType<typeof betterAuth>;

/**
 * Generates a cryptographically secure random secret.
 * Used as fallback when no BETTER_AUTH_SECRET is configured.
 *
 * NOTE: This secret is generated at server startup, meaning:
 * - All existing sessions become invalid on server restart
 * - This is acceptable for development environments
 * - For production, ALWAYS set BETTER_AUTH_SECRET to maintain sessions across restarts
 */
function generateSecureSecret(): string {
  return crypto.randomBytes(32).toString('base64');
}

/**
 * Cached auto-generated secret for the current server instance.
 * Generated once at module load to ensure consistency within a single run.
 */
let cachedAutoGeneratedSecret: null | string = null;

/**
 * Options for creating a better-auth instance
 */
export interface CreateBetterAuthOptions {
  /**
   * Better-auth configuration from server options
   */
  config: IBetterAuth;

  /**
   * MongoDB database instance
   * Note: Uses 'any' type to handle version incompatibilities between
   * mongoose's bundled mongodb types and the project's mongodb package.
   * At runtime, this is a mongodb.Db instance.
   */
  db: any;

  /**
   * Fallback secrets to try if no betterAuth.secret is configured.
   * The array is iterated and the first valid secret (‚â•32 chars) is used.
   * If no valid secret is found, an auto-generated secret is used.
   *
   * Typical usage: Pass existing secrets from your config (e.g., jwt.secret)
   * for backwards compatibility.
   *
   * @example
   * ```typescript
   * fallbackSecrets: [config.jwt?.secret, config.jwt?.refresh?.secret]
   * ```
   */
  fallbackSecrets?: (string | undefined)[];
}

/**
 * Social provider configuration for better-auth
 */
interface SocialProviderConfig {
  clientId: string;
  clientSecret: string;
}

/**
 * Social provider names supported by the configuration
 */
type SocialProviderName = 'apple' | 'github' | 'google';

/**
 * Validation result for configuration
 */
interface ValidationResult {
  errors: string[];
  valid: boolean;
  warnings: string[];
}

/**
 * Creates a better-auth instance based on configuration
 *
 * @param options - Configuration options including betterAuth config and MongoDB connection
 * @returns Configured better-auth instance or null if not enabled
 * @throws Error if configuration validation fails
 */
export function createBetterAuthInstance(options: CreateBetterAuthOptions): BetterAuthInstance | null {
  const logger = new Logger('BetterAuthConfig');
  const { config, db, fallbackSecrets } = options;

  // Return null only if better-auth is explicitly disabled
  // BetterAuth is enabled by default (zero-config)
  if (config?.enabled === false) {
    return null;
  }

  // Validate configuration (with fallback secrets for backwards compatibility)
  const validation = validateConfig(config, fallbackSecrets);

  // Log warnings
  for (const warning of validation.warnings) {
    logger.warn(warning);
  }

  // Throw on validation errors
  if (!validation.valid) {
    throw new Error(`BetterAuth configuration invalid: ${validation.errors.join('; ')}`);
  }

  // Build configuration components
  const plugins = buildPlugins(config);
  const socialProviders = buildSocialProviders(config);
  const trustedOrigins = buildTrustedOrigins(config);

  // Create and return the better-auth instance
  // Using user configuration to integrate with existing users collection
  return betterAuth({
    basePath: config.basePath || '/iam',
    baseURL: config.baseUrl || 'http://localhost:3000',
    database: mongodbAdapter(db),
    plugins,
    secret: config.secret,
    socialProviders,
    trustedOrigins,
    user: {
      // Map Better-Auth fields to our User model fields
      // Note: twoFactorSecret is managed by Better-Auth's twoFactor plugin in separate table
      additionalFields: {
        firstName: {
          defaultValue: null,
          fieldName: 'firstName',
          type: 'string',
        },
        iamId: {
          defaultValue: null,
          fieldName: 'iamId',
          type: 'string',
        },
        lastName: {
          defaultValue: null,
          fieldName: 'lastName',
          type: 'string',
        },
        roles: {
          defaultValue: [],
          fieldName: 'roles',
          type: 'string[]',
        },
        twoFactorEnabled: {
          defaultValue: false,
          fieldName: 'twoFactorEnabled',
          type: 'boolean',
        },
        verified: {
          defaultValue: false,
          fieldName: 'verified',
          type: 'boolean',
        },
      },
      modelName: 'users',
    },
  });
}

/**
 * Builds the plugins array based on configuration
 */
function buildPlugins(config: IBetterAuth): BetterAuthPlugin[] {
  const plugins: BetterAuthPlugin[] = [];

  // JWT Plugin for API client compatibility
  if (config.jwt?.enabled) {
    plugins.push(
      jwt({
        jwt: {
          expirationTime: config.jwt.expiresIn || '15m',
        },
      }),
    );
  }

  // Two-Factor Authentication Plugin
  if (config.twoFactor?.enabled) {
    plugins.push(
      twoFactor({
        issuer: config.twoFactor.appName || 'Nest Server',
      }),
    );
  }

  // Passkey/WebAuthn Plugin
  if (config.passkey?.enabled) {
    plugins.push(
      passkey({
        origin: config.passkey.origin || 'http://localhost:3000',
        rpID: config.passkey.rpId || 'localhost',
        rpName: config.passkey.rpName || 'Nest Server',
      }),
    );
  }

  return plugins;
}

/**
 * Builds the social providers configuration object
 */
function buildSocialProviders(config: IBetterAuth): Partial<Record<SocialProviderName, SocialProviderConfig>> {
  const socialProvidersConfig: Partial<Record<SocialProviderName, SocialProviderConfig>> = {};
  const providerNames: SocialProviderName[] = ['apple', 'github', 'google'];

  for (const name of providerNames) {
    const provider: IBetterAuthSocialProvider | undefined = config.socialProviders?.[name];
    if (provider?.enabled && provider.clientId && provider.clientSecret) {
      socialProvidersConfig[name] = {
        clientId: provider.clientId,
        clientSecret: provider.clientSecret,
      };
    }
  }

  return socialProvidersConfig;
}

/**
 * Builds the trusted origins array
 */
function buildTrustedOrigins(config: IBetterAuth): string[] {
  if (config.trustedOrigins?.length) {
    return config.trustedOrigins;
  }
  if (config.baseUrl) {
    return [config.baseUrl];
  }
  return ['http://localhost:3000'];
}

/**
 * Gets or generates the fallback secret for development.
 * The secret is cached to ensure consistency during the server's lifetime.
 */
function getAutoGeneratedSecret(): string {
  if (!cachedAutoGeneratedSecret) {
    cachedAutoGeneratedSecret = generateSecureSecret();
  }
  return cachedAutoGeneratedSecret;
}

/**
 * Checks if a secret has valid minimum length (32 characters)
 */
function isValidSecretLength(secret: string): boolean {
  return secret && secret.length >= 32;
}

/**
 * Validates a URL string
 */
function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * Validates the better-auth configuration and applies fallback secret if needed.
 * Mutates config.secret if fallback is applied.
 *
 * Secret resolution order:
 * 1. betterAuth.secret (if configured and valid)
 * 2. First valid secret from fallbackSecrets array (‚â•32 chars)
 * 3. Auto-generated secure secret (with warning)
 *
 * @param config - Better-auth configuration
 * @param fallbackSecrets - Optional array of fallback secrets to try
 */
function validateConfig(config: IBetterAuth, fallbackSecrets?: (string | undefined)[]): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Track secret source for appropriate messaging
  let secretSource: 'auto-generated' | 'explicit' | 'fallback' = 'explicit';

  // Resolve secret with fallback chain
  if (!config.secret || config.secret.trim() === '') {
    // Try fallback secrets in order
    const validFallback = fallbackSecrets?.find((secret) => secret && isValidSecretLength(secret));

    if (validFallback) {
      config.secret = validFallback;
      secretSource = 'fallback';
    } else {
      // Last resort: auto-generate
      config.secret = getAutoGeneratedSecret();
      secretSource = 'auto-generated';
    }
  }

  // Validate the resolved secret
  const secretValidation = validateSecret(config.secret);
  if (!secretValidation.valid) {
    errors.push(secretValidation.message!);
  } else if (secretValidation.message) {
    warnings.push(secretValidation.message);
  }

  // Log information about secret source
  switch (secretSource) {
    case 'auto-generated':
      warnings.push('‚ö†Ô∏è  BETTER_AUTH: No secret configured - using auto-generated secret.');
      warnings.push('‚ö†Ô∏è  CONSEQUENCE: All user sessions will be invalidated on server restart!');
      warnings.push(
        'üí° FOR PRODUCTION: Set betterAuth.secret in config or provide a valid fallback secret (min 32 chars).',
      );
      warnings.push("üí° Generate with: node -e \"console.log(require('crypto').randomBytes(32).toString('base64'))\"");
      break;
    case 'fallback':
      warnings.push(
        'üí° BETTER_AUTH: Using fallback secret (backwards compatible). Consider setting betterAuth.secret explicitly.',
      );
      break;
    // 'explicit' - no warning needed, explicitly configured
  }

  // Validate baseUrl
  if (config.baseUrl && !isValidUrl(config.baseUrl)) {
    errors.push(`Invalid baseUrl format: ${config.baseUrl}`);
  }

  // Validate trustedOrigins
  if (config.trustedOrigins) {
    for (const origin of config.trustedOrigins) {
      if (!isValidUrl(origin)) {
        errors.push(`Invalid trustedOrigin format: ${origin}`);
      }
    }
  }

  // Validate passkey origin
  if (config.passkey?.enabled && config.passkey.origin && !isValidUrl(config.passkey.origin)) {
    errors.push(`Invalid passkey origin format: ${config.passkey.origin}`);
  }

  // Validate social providers
  const providerNames: SocialProviderName[] = ['google', 'github', 'apple'];
  for (const name of providerNames) {
    const provider = config.socialProviders?.[name];
    if (provider?.enabled) {
      if (!provider.clientId) {
        errors.push(`Social provider '${name}' is enabled but missing clientId`);
      }
      if (!provider.clientSecret) {
        errors.push(`Social provider '${name}' is enabled but missing clientSecret`);
      }
    }
  }

  return {
    errors,
    valid: errors.length === 0,
    warnings,
  };
}

/**
 * Validates the secret strength
 * Requirements: min 32 chars, should contain mixed characters
 */
function validateSecret(secret: string): { message?: string; valid: boolean } {
  if (!secret || secret.length < 32) {
    return { message: 'Secret must be at least 32 characters long', valid: false };
  }

  // Check for character diversity (at least 2 of: lowercase, uppercase, numbers, special)
  const hasLowercase = /[a-z]/.test(secret);
  const hasUppercase = /[A-Z]/.test(secret);
  const hasNumbers = /[0-9]/.test(secret);
  const hasSpecial = /[^a-zA-Z0-9]/.test(secret);
  const diversityCount = [hasLowercase, hasUppercase, hasNumbers, hasSpecial].filter(Boolean).length;

  if (diversityCount < 2) {
    return {
      message: 'Secret should contain at least 2 different character types (lowercase, uppercase, numbers, special)',
      valid: true, // Warning only, not an error
    };
  }

  return { valid: true };
}
