import { passkey } from '@better-auth/passkey';
import { Logger } from '@nestjs/common';
import { betterAuth, BetterAuthPlugin } from 'better-auth';
import { mongodbAdapter } from 'better-auth/adapters/mongodb';
import { jwt, twoFactor } from 'better-auth/plugins';
import * as crypto from 'crypto';

import { IBetterAuth } from '../../common/interfaces/server-options.interface';

/**
 * Type for better-auth instance with plugins
 */
export type BetterAuthInstance = ReturnType<typeof betterAuth>;

/**
 * Generates a cryptographically secure random secret.
 * Used as fallback when no BETTER_AUTH_SECRET is configured.
 *
 * NOTE: This secret is generated at server startup, meaning:
 * - All existing sessions become invalid on server restart
 * - This is acceptable for development environments
 * - For production, ALWAYS set BETTER_AUTH_SECRET to maintain sessions across restarts
 */
function generateSecureSecret(): string {
  return crypto.randomBytes(32).toString('base64');
}

/**
 * Cached auto-generated secret for the current server instance.
 * Generated once at module load to ensure consistency within a single run.
 */
let cachedAutoGeneratedSecret: null | string = null;

/**
 * Options for creating a better-auth instance
 */
export interface CreateBetterAuthOptions {
  /**
   * Better-auth configuration from server options
   */
  config: IBetterAuth;

  /**
   * MongoDB database instance
   * Note: Uses 'any' type to handle version incompatibilities between
   * mongoose's bundled mongodb types and the project's mongodb package.
   * At runtime, this is a mongodb.Db instance.
   */
  db: any;

  /**
   * Fallback secrets to try if no betterAuth.secret is configured.
   * The array is iterated and the first valid secret (≥32 chars) is used.
   * If no valid secret is found, an auto-generated secret is used.
   *
   * Typical usage: Pass existing secrets from your config (e.g., jwt.secret)
   * for backwards compatibility.
   *
   * @example
   * ```typescript
   * fallbackSecrets: [config.jwt?.secret, config.jwt?.refresh?.secret]
   * ```
   */
  fallbackSecrets?: (string | undefined)[];

  /**
   * Server-level app/frontend URL (from IServerOptions.appUrl).
   * Used for Passkey origin and CORS trustedOrigins.
   */
  serverAppUrl?: string;

  /**
   * Server-level base URL (from IServerOptions.baseUrl).
   * Used as fallback for betterAuth.baseUrl.
   */
  serverBaseUrl?: string;

  /**
   * Server environment (from IServerOptions.env).
   * Used for local environment defaults.
   */
  serverEnv?: string;
}

/**
 * Better-Auth field type definition
 * Matches the DBFieldType from better-auth
 */
type BetterAuthFieldType = 'boolean' | 'date' | 'json' | 'number' | 'number[]' | 'string' | 'string[]';

/**
 * Normalized Passkey configuration with required fields
 */
interface NormalizedPasskeyConfig {
  authenticatorAttachment?: 'cross-platform' | 'platform';
  challengeStorage?: 'cookie' | 'database';
  challengeTtlSeconds?: number;
  origin: string;
  residentKey?: 'discouraged' | 'preferred' | 'required';
  rpId: string;
  rpName: string;
  userVerification?: 'discouraged' | 'preferred' | 'required';
  webAuthnChallengeCookie?: string;
}

/**
 * Result of Passkey configuration normalization
 */
interface PasskeyNormalizationResult {
  /**
   * Whether Passkey should be enabled after normalization
   */
  enabled: boolean;

  /**
   * Normalized Passkey configuration (with auto-detected values)
   */
  normalizedConfig: NormalizedPasskeyConfig | null;

  /**
   * Auto-detected trustedOrigins (to be merged with config)
   */
  trustedOrigins: null | string[];

  /**
   * Warnings generated during normalization
   */
  warnings: string[];
}

/**
 * Social provider configuration for better-auth
 */
interface SocialProviderConfig {
  clientId: string;
  clientSecret: string;
}

/**
 * User field configuration type for Better-Auth
 * Matches the DBFieldAttribute structure from better-auth
 */
interface UserFieldConfig {
  defaultValue?: unknown;
  fieldName?: string;
  required?: boolean;
  type: BetterAuthFieldType;
}

/**
 * Validation result for configuration
 */
interface ValidationResult {
  errors: string[];
  valid: boolean;
  warnings: string[];
}

/**
 * Creates a better-auth instance based on configuration
 *
 * @param options - Configuration options including betterAuth config and MongoDB connection
 * @returns Configured better-auth instance or null if not enabled
 * @throws Error if configuration validation fails
 */
export function createBetterAuthInstance(options: CreateBetterAuthOptions): BetterAuthInstance | null {
  const logger = new Logger('BetterAuthConfig');
  const { config, db, fallbackSecrets } = options;

  // Return null only if better-auth is explicitly disabled
  // BetterAuth is enabled by default (zero-config)
  if (config?.enabled === false) {
    return null;
  }

  // Resolve URLs with auto-detection and local defaults
  const resolvedUrls = resolveUrls(options);

  // Log URL resolution warnings
  for (const warning of resolvedUrls.warnings) {
    logger.log(warning);
  }

  // Normalize Passkey configuration with auto-detection from resolved URLs
  // This must happen BEFORE validation to allow graceful degradation
  // Passkey is now AUTO-ACTIVATED by default (not opt-in)
  const passkeyNormalization = normalizePasskeyConfig(config, resolvedUrls);

  // Log passkey normalization warnings (info about auto-detection or disabled status)
  for (const warning of passkeyNormalization.warnings) {
    logger.warn(warning);
  }

  // Validate configuration (with fallback secrets for backwards compatibility)
  const validation = validateConfig(config, fallbackSecrets, passkeyNormalization);

  // Log warnings
  for (const warning of validation.warnings) {
    logger.warn(warning);
  }

  // Throw on validation errors
  if (!validation.valid) {
    throw new Error(`BetterAuth configuration invalid: ${validation.errors.join('; ')}`);
  }

  // Build configuration components (pass normalized passkey config and resolved URLs)
  const plugins = buildPlugins(config, passkeyNormalization);
  const socialProviders = buildSocialProviders(config);
  const trustedOrigins = buildTrustedOrigins(config, passkeyNormalization, resolvedUrls);
  const additionalFields = buildUserFields(config);

  // Build the base Better-Auth configuration
  // Use resolved baseUrl (with local defaults) or fallback
  const basePath = config.basePath || '/iam';
  // Cookie prefix derived from basePath (e.g., '/iam' → 'iam')
  // This ensures Better-Auth looks for cookies like 'iam.session_token' instead of 'better-auth.session_token'
  const cookiePrefix = basePath.replace(/^\//, '').replace(/\//g, '.');

  const betterAuthConfig: Record<string, unknown> = {
    advanced: {
      cookiePrefix,
    },
    basePath,
    baseURL: resolvedUrls.baseUrl || config.baseUrl || 'http://localhost:3000',
    database: mongodbAdapter(db),
    // Enable email/password authentication by default (required by Better-Auth 1.x)
    // Can be disabled by setting config.emailAndPassword.enabled = false
    emailAndPassword: {
      enabled: config.emailAndPassword?.enabled !== false,
    },
    plugins,
    secret: config.secret,
    socialProviders,
    user: {
      additionalFields,
      modelName: 'users',
    },
  };

  // Only add trustedOrigins if explicitly configured
  // When undefined, Better-Auth uses its default CORS behavior (allows all origins)
  if (trustedOrigins) {
    betterAuthConfig.trustedOrigins = trustedOrigins;
  }

  // Merge with custom options passthrough
  // This allows projects to configure any Better-Auth option not explicitly defined
  const finalConfig = config.options ? { ...betterAuthConfig, ...config.options } : betterAuthConfig;

  // Create and return the better-auth instance
  // Type assertion needed for maximum flexibility - allows projects to use any Better-Auth option

  return betterAuth(finalConfig as any);
}

/**
 * Builds the plugins array based on configuration.
 * Merges built-in plugins (jwt, twoFactor, passkey) with custom plugins from config.
 *
 * Plugins accept both boolean and object configuration:
 * - `true` or `{}`: Enable with defaults
 * - `{ option: value }`: Enable with custom settings
 * - `false` or `{ enabled: false }`: Disable
 * - `undefined`: Disabled (default)
 *
 * @param config - Better-auth configuration
 * @param passkeyNormalization - Normalized passkey configuration from normalizePasskeyConfig()
 */
function buildPlugins(config: IBetterAuth, passkeyNormalization: PasskeyNormalizationResult): BetterAuthPlugin[] {
  const plugins: BetterAuthPlugin[] = [];

  // JWT Plugin for API client compatibility
  // JWT is enabled by default unless explicitly disabled (jwt: false or jwt: { enabled: false })
  const jwtExplicitlyDisabled =
    config.jwt === false || (typeof config.jwt === 'object' && config.jwt?.enabled === false);
  if (!jwtExplicitlyDisabled) {
    const jwtConfig = typeof config.jwt === 'object' ? config.jwt : {};
    plugins.push(
      jwt({
        jwt: {
          expirationTime: jwtConfig.expiresIn || '15m',
        },
      }),
    );
  }

  // Two-Factor Authentication Plugin
  // 2FA is enabled by default unless explicitly disabled (twoFactor: false or twoFactor: { enabled: false })
  const twoFactorExplicitlyDisabled =
    config.twoFactor === false || (typeof config.twoFactor === 'object' && config.twoFactor?.enabled === false);
  if (!twoFactorExplicitlyDisabled) {
    const twoFactorConfig = typeof config.twoFactor === 'object' ? config.twoFactor : {};
    plugins.push(
      twoFactor({
        issuer: twoFactorConfig.appName || 'Nest Server',
      }),
    );
  }

  // Passkey/WebAuthn Plugin
  // Uses normalized config from normalizePasskeyConfig() which handles auto-detection
  if (passkeyNormalization.enabled && passkeyNormalization.normalizedConfig) {
    const normalizedPasskey = passkeyNormalization.normalizedConfig;

    // Build passkey options from normalized config
    const passkeyOptions: Record<string, unknown> = {
      origin: normalizedPasskey.origin,
      rpID: normalizedPasskey.rpId,
      rpName: normalizedPasskey.rpName,
    };

    // Add optional WebAuthn configuration if specified
    if (normalizedPasskey.authenticatorAttachment) {
      passkeyOptions.authenticatorAttachment = normalizedPasskey.authenticatorAttachment;
    }
    if (normalizedPasskey.residentKey) {
      passkeyOptions.residentKey = normalizedPasskey.residentKey;
    }
    if (normalizedPasskey.userVerification) {
      passkeyOptions.userVerification = normalizedPasskey.userVerification;
    }
    if (normalizedPasskey.webAuthnChallengeCookie) {
      passkeyOptions.webAuthnChallengeCookie = normalizedPasskey.webAuthnChallengeCookie;
    }

    plugins.push(passkey(passkeyOptions));
  }

  // Merge custom plugins from configuration
  // This allows projects to add any Better-Auth plugin without modifying this package
  if (config.plugins?.length) {
    plugins.push(...(config.plugins as BetterAuthPlugin[]));
  }

  return plugins;
}

/**
 * Builds the social providers configuration object dynamically.
 * Iterates over all configured providers and includes those that are enabled
 * with valid clientId and clientSecret.
 */
function buildSocialProviders(config: IBetterAuth): Record<string, SocialProviderConfig> {
  const socialProvidersConfig: Record<string, SocialProviderConfig> = {};

  // Iterate over all configured social providers dynamically
  // A provider is enabled by default if it has credentials configured
  // It can be explicitly disabled by setting enabled: false
  if (config.socialProviders) {
    for (const [name, provider] of Object.entries(config.socialProviders)) {
      if (provider?.clientId && provider?.clientSecret && provider?.enabled !== false) {
        socialProvidersConfig[name] = {
          clientId: provider.clientId,
          clientSecret: provider.clientSecret,
        };
      }
    }
  }

  return socialProvidersConfig;
}

/**
 * Builds the trusted origins array for CORS configuration.
 *
 * Behavior:
 * - If trustedOrigins is explicitly configured → use those origins
 * - If Passkey is enabled → use trustedOrigins from normalizePasskeyConfig()
 * - Fallback to resolved appUrl
 * - Otherwise → return undefined (allows all origins via Better-Auth's default)
 *
 * @param config - Better-auth configuration
 * @param passkeyNormalization - Normalized passkey configuration from normalizePasskeyConfig()
 * @param resolvedUrls - Resolved URLs from resolveUrls()
 */
function buildTrustedOrigins(
  config: IBetterAuth,
  passkeyNormalization: PasskeyNormalizationResult,
  resolvedUrls: ResolvedUrls,
): string[] | undefined {
  // If trustedOrigins is explicitly configured, use it
  if (config.trustedOrigins?.length) {
    return config.trustedOrigins;
  }

  // If Passkey is enabled, use the trustedOrigins from normalization
  if (passkeyNormalization.enabled && passkeyNormalization.trustedOrigins?.length) {
    return passkeyNormalization.trustedOrigins;
  }

  // Fallback to resolved appUrl (for CORS even without Passkey)
  if (resolvedUrls.appUrl) {
    return [resolvedUrls.appUrl];
  }

  // Otherwise, let Better-Auth handle CORS with its default behavior
  // This allows all origins for requests without credentials
  return undefined;
}

/**
 * Builds the user additional fields configuration.
 * Merges core fields (firstName, lastName, etc.) with custom fields from config.
 * Custom fields override core fields if they have the same key.
 */
function buildUserFields(config: IBetterAuth): Record<string, UserFieldConfig> {
  // Core fields required for nest-server functionality
  const coreFields: Record<string, UserFieldConfig> = {
    firstName: {
      defaultValue: null,
      fieldName: 'firstName',
      type: 'string',
    },
    iamId: {
      defaultValue: null,
      fieldName: 'iamId',
      type: 'string',
    },
    lastName: {
      defaultValue: null,
      fieldName: 'lastName',
      type: 'string',
    },
    roles: {
      defaultValue: [],
      fieldName: 'roles',
      type: 'string[]',
    },
    twoFactorEnabled: {
      defaultValue: false,
      fieldName: 'twoFactorEnabled',
      type: 'boolean',
    },
    verified: {
      defaultValue: false,
      fieldName: 'verified',
      type: 'boolean',
    },
  };

  // Merge with custom additional fields from configuration
  // Custom fields can override core fields or add new ones
  if (config.additionalUserFields) {
    for (const [key, field] of Object.entries(config.additionalUserFields)) {
      coreFields[key] = {
        defaultValue: field.defaultValue,
        fieldName: field.fieldName || key,
        required: field.required,
        type: field.type,
      };
    }
  }

  return coreFields;
}

/**
 * Gets or generates the fallback secret for development.
 * The secret is cached to ensure consistency during the server's lifetime.
 */
function getAutoGeneratedSecret(): string {
  if (!cachedAutoGeneratedSecret) {
    cachedAutoGeneratedSecret = generateSecureSecret();
  }
  return cachedAutoGeneratedSecret;
}

/**
 * Checks if a secret has valid minimum length (32 characters)
 */
function isValidSecretLength(secret: string): boolean {
  return secret && secret.length >= 32;
}

/**
 * Validates a URL string
 */
function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * Default URLs for local/test environments (local, ci, e2e)
 * These environments typically run on localhost and don't have a deployed domain.
 */
const LOCALHOST_DEFAULTS = {
  API_URL: 'http://localhost:3000',
  APP_URL: 'http://localhost:3001',
};

/**
 * Environments that use localhost defaults for URLs.
 * These are typically development/test environments without deployed domains.
 */
const LOCALHOST_ENVS = ['local', 'ci', 'e2e'];

/**
 * Resolves the effective URLs for BetterAuth configuration.
 *
 * Resolution priority:
 * 1. Explicit betterAuth config values
 * 2. Server-level URLs (IServerOptions.baseUrl, IServerOptions.appUrl)
 * 3. Auto-derived values (appUrl from baseUrl)
 * 4. Local environment defaults (when env: 'local')
 *
 * @param options - CreateBetterAuthOptions containing config and server URLs
 * @returns Resolved URLs with warnings for logging
 */
interface ResolvedUrls {
  appUrl: string | undefined;
  baseUrl: string | undefined;
  rpId: string | undefined;
  warnings: string[];
}

/**
 * Derives appUrl from baseUrl by removing 'api.' prefix from subdomain.
 *
 * Examples:
 * - 'https://api.example.com' → 'https://example.com'
 * - 'https://api.dev.example.com' → 'https://dev.example.com'
 * - 'https://example.com' → 'https://example.com' (unchanged)
 * - 'http://localhost:3000' → 'http://localhost:3000' (unchanged)
 *
 * @param baseUrl - The API base URL
 * @returns Derived app URL or the original URL if no 'api.' prefix
 */
function deriveAppUrlFromBaseUrl(baseUrl: string): string {
  try {
    const url = new URL(baseUrl);
    const hostname = url.hostname;

    // Check if hostname starts with 'api.'
    if (hostname.startsWith('api.')) {
      // Remove 'api.' prefix
      url.hostname = hostname.substring(4);
      return url.origin;
    }

    // Return original URL if no 'api.' prefix
    return url.origin;
  } catch {
    return baseUrl;
  }
}

/**
 * Extracts the root domain from a URL for use as Passkey rpId.
 *
 * For localhost: Returns 'localhost' (not 'localhost:3000')
 * For domains: Returns the registrable domain (e.g., 'example.com')
 *
 * Examples:
 * - 'https://api.example.com' → 'example.com'
 * - 'https://app.dev.example.com' → 'example.com'
 * - 'http://localhost:3000' → 'localhost'
 * - 'https://example.com' → 'example.com'
 *
 * @param url - The URL to extract rpId from
 * @returns The root domain suitable for Passkey rpId
 */
function extractRpIdFromUrl(url: string): string {
  try {
    const parsedUrl = new URL(url);
    const hostname = parsedUrl.hostname;

    // localhost is a special case
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return 'localhost';
    }

    // For regular domains, extract the registrable domain
    // This is a simplified approach - for complex TLDs like .co.uk, a library would be better
    const parts = hostname.split('.');

    // If it's just a simple domain (example.com), return it
    if (parts.length <= 2) {
      return hostname;
    }

    // For subdomains, return the last two parts (example.com from api.example.com)
    // Note: This doesn't handle .co.uk style TLDs correctly, but works for common cases
    return parts.slice(-2).join('.');
  } catch {
    return 'localhost';
  }
}

/**
 * Normalizes Passkey configuration with auto-detection from resolved URLs.
 *
 * **AUTO-ACTIVATION:** Passkey is enabled by default when BetterAuth is active.
 * It is only disabled when:
 * 1. Explicitly disabled: `passkey: false` or `passkey: { enabled: false }`
 * 2. Required URLs cannot be resolved (Graceful Degradation)
 *
 * Auto-Detection Logic (using resolvedUrls from resolveUrls()):
 * - `rpId`: from passkey.rpId > resolvedUrls.rpId (derived from appUrl)
 * - `origin`: from passkey.origin > resolvedUrls.appUrl
 * - `trustedOrigins`: from config.trustedOrigins > [resolvedUrls.appUrl]
 *
 * @param config - Better-auth configuration
 * @param resolvedUrls - Resolved URLs from resolveUrls()
 * @returns Normalization result with enabled status, config, and warnings
 */
function normalizePasskeyConfig(config: IBetterAuth, resolvedUrls: ResolvedUrls): PasskeyNormalizationResult {
  const warnings: string[] = [];

  // Check if Passkey is explicitly DISABLED
  // passkey: false OR passkey: { enabled: false }
  const isExplicitlyDisabled =
    config.passkey === false || (typeof config.passkey === 'object' && config.passkey?.enabled === false);

  if (isExplicitlyDisabled) {
    return { enabled: false, normalizedConfig: null, trustedOrigins: null, warnings };
  }

  // Get the raw passkey config (if object)
  const rawConfig = typeof config.passkey === 'object' ? config.passkey : {};

  // Resolve values: explicit config > resolved URLs
  const finalRpId = rawConfig.rpId || resolvedUrls.rpId;
  const finalOrigin = rawConfig.origin || resolvedUrls.appUrl;
  const finalTrustedOrigins = config.trustedOrigins?.length ? config.trustedOrigins : resolvedUrls.appUrl ? [resolvedUrls.appUrl] : undefined;

  // Check if we have all required values for Passkey
  const hasRequiredConfig = finalRpId && finalOrigin && finalTrustedOrigins?.length;

  if (!hasRequiredConfig) {
    // Graceful Degradation: Disable Passkey with warning
    const missingFields: string[] = [];
    if (!finalRpId) missingFields.push('rpId');
    if (!finalOrigin) missingFields.push('origin');
    if (!finalTrustedOrigins?.length) missingFields.push('trustedOrigins');

    warnings.push(
      `⚠️ PASSKEY DISABLED: Cannot auto-detect required values (${missingFields.join(', ')}). ` +
        'To enable Passkey, set baseUrl in your config or configure passkey values explicitly.',
    );
    warnings.push(
      'Fix options:\n' +
        '  1. Set baseUrl: "https://api.example.com" → auto-detects appUrl, rpId, origin\n' +
        '  2. Set env: "local" → uses localhost:3000 (API) and localhost:3001 (App) defaults\n' +
        '  3. Disable Passkey explicitly: passkey: false (no warning)',
    );

    return { enabled: false, normalizedConfig: null, trustedOrigins: null, warnings };
  }

  // Log auto-detection info
  if (!rawConfig.rpId && resolvedUrls.rpId) {
    warnings.push(`PASSKEY: Using rpId="${finalRpId}" (auto-detected from appUrl)`);
  }
  if (!rawConfig.origin && resolvedUrls.appUrl) {
    warnings.push(`PASSKEY: Using origin="${finalOrigin}" (= appUrl)`);
  }
  if (!config.trustedOrigins?.length && resolvedUrls.appUrl) {
    warnings.push(`PASSKEY: Using trustedOrigins=${JSON.stringify(finalTrustedOrigins)} (= [appUrl])`);
  }

  // Build normalized config
  const normalizedConfig: NormalizedPasskeyConfig = {
    origin: finalOrigin,
    rpId: finalRpId,
    rpName: rawConfig.rpName || 'Nest Server',
  };

  // Copy optional fields from explicit config
  if (rawConfig.authenticatorAttachment) {
    normalizedConfig.authenticatorAttachment = rawConfig.authenticatorAttachment;
  }
  if (rawConfig.challengeStorage) {
    normalizedConfig.challengeStorage = rawConfig.challengeStorage;
  }
  if (rawConfig.challengeTtlSeconds) {
    normalizedConfig.challengeTtlSeconds = rawConfig.challengeTtlSeconds;
  }
  if (rawConfig.residentKey) {
    normalizedConfig.residentKey = rawConfig.residentKey;
  }
  if (rawConfig.userVerification) {
    normalizedConfig.userVerification = rawConfig.userVerification;
  }
  if (rawConfig.webAuthnChallengeCookie) {
    normalizedConfig.webAuthnChallengeCookie = rawConfig.webAuthnChallengeCookie;
  }

  return {
    enabled: true,
    normalizedConfig,
    trustedOrigins: finalTrustedOrigins,
    warnings,
  };
}

function resolveUrls(options: CreateBetterAuthOptions): ResolvedUrls {
  const { config, serverAppUrl, serverBaseUrl, serverEnv } = options;
  const warnings: string[] = [];
  const usesLocalhostDefaults = LOCALHOST_ENVS.includes(serverEnv || '');

  // Step 1: Resolve baseUrl
  // Priority: betterAuth.baseUrl > serverBaseUrl > localhost default (for local/ci/e2e)
  let baseUrl = config.baseUrl || serverBaseUrl;
  if (!baseUrl && usesLocalhostDefaults) {
    baseUrl = LOCALHOST_DEFAULTS.API_URL;
    warnings.push(`URL: Using localhost default baseUrl="${baseUrl}" (env: '${serverEnv}')`);
  }

  // Step 2: Resolve appUrl
  // Priority: serverAppUrl > localhost default (when baseUrl is localhost) > derived from baseUrl
  let appUrl = serverAppUrl;

  // For localhost environments with localhost baseUrl, use localhost app default
  // This handles the common case where API runs on :3000 and App on :3001
  const isBaseUrlLocalhost = baseUrl && (baseUrl.includes('localhost') || baseUrl.includes('127.0.0.1'));
  if (!appUrl && usesLocalhostDefaults && isBaseUrlLocalhost) {
    appUrl = LOCALHOST_DEFAULTS.APP_URL;
    warnings.push(`URL: Using localhost default appUrl="${appUrl}" (env: '${serverEnv}')`);
  }

  // For non-localhost environments, try to derive appUrl from baseUrl
  if (!appUrl && baseUrl) {
    appUrl = deriveAppUrlFromBaseUrl(baseUrl);
    if (appUrl !== baseUrl) {
      warnings.push(`URL: Auto-derived appUrl="${appUrl}" from baseUrl="${baseUrl}"`);
    }
  }

  // Step 3: Resolve rpId from appUrl (not baseUrl!)
  // rpId should be the domain where the user authenticates (app domain)
  let rpId: string | undefined;
  if (appUrl) {
    rpId = extractRpIdFromUrl(appUrl);
  }

  return { appUrl, baseUrl, rpId, warnings };
}

/**
 * Validates the better-auth configuration and applies fallback secret if needed.
 * Mutates config.secret if fallback is applied.
 *
 * Secret resolution order:
 * 1. betterAuth.secret (if configured and valid)
 * 2. First valid secret from fallbackSecrets array (≥32 chars)
 * 3. Auto-generated secure secret (with warning)
 *
 * @param config - Better-auth configuration
 * @param fallbackSecrets - Optional array of fallback secrets to try
 * @param passkeyNormalization - Result of passkey normalization (handles graceful degradation)
 */
function validateConfig(
  config: IBetterAuth,
  fallbackSecrets?: (string | undefined)[],
  passkeyNormalization?: PasskeyNormalizationResult,
): ValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Track secret source for appropriate messaging
  let secretSource: 'auto-generated' | 'explicit' | 'fallback' = 'explicit';

  // Resolve secret with fallback chain
  if (!config.secret || config.secret.trim() === '') {
    // Try fallback secrets in order
    const validFallback = fallbackSecrets?.find((secret) => secret && isValidSecretLength(secret));

    if (validFallback) {
      config.secret = validFallback;
      secretSource = 'fallback';
    } else {
      // Last resort: auto-generate
      config.secret = getAutoGeneratedSecret();
      secretSource = 'auto-generated';
    }
  }

  // Validate the resolved secret
  const secretValidation = validateSecret(config.secret);
  if (!secretValidation.valid) {
    errors.push(secretValidation.message!);
  } else if (secretValidation.message) {
    warnings.push(secretValidation.message);
  }

  // Log information about secret source
  switch (secretSource) {
    case 'auto-generated':
      warnings.push('BETTER_AUTH: No secret configured - using auto-generated secret.');
      warnings.push('CONSEQUENCE: All user sessions will be invalidated on server restart!');
      warnings.push(
        'FOR PRODUCTION: Set betterAuth.secret in config or provide a valid fallback secret (min 32 chars).',
      );
      warnings.push("Generate with: node -e \"console.log(require('crypto').randomBytes(32).toString('base64'))\"");
      break;
    case 'fallback':
      warnings.push(
        'BETTER_AUTH: Using fallback secret (backwards compatible). Consider setting betterAuth.secret explicitly.',
      );
      break;
    // 'explicit' - no warning needed, explicitly configured
  }

  // Validate baseUrl
  if (config.baseUrl && !isValidUrl(config.baseUrl)) {
    errors.push(`Invalid baseUrl format: ${config.baseUrl}`);
  }

  // Validate trustedOrigins (if explicitly configured)
  if (config.trustedOrigins) {
    for (const origin of config.trustedOrigins) {
      if (!isValidUrl(origin)) {
        errors.push(`Invalid trustedOrigin format: ${origin}`);
      }
    }
  }

  // Validate auto-detected trustedOrigins from passkey normalization
  if (passkeyNormalization?.trustedOrigins) {
    for (const origin of passkeyNormalization.trustedOrigins) {
      if (!isValidUrl(origin)) {
        errors.push(`Invalid auto-detected trustedOrigin format: ${origin}`);
      }
    }
  }

  // Validate passkey origin (only if passkey is enabled after normalization)
  if (passkeyNormalization?.enabled && passkeyNormalization.normalizedConfig) {
    const normalizedOrigin = passkeyNormalization.normalizedConfig.origin;
    if (!isValidUrl(normalizedOrigin)) {
      errors.push(`Invalid passkey origin format: ${normalizedOrigin}`);
    }
  }

  // Validate social providers dynamically
  // Providers are enabled by default unless explicitly disabled (enabled: false)
  // We only validate credentials for providers that are not explicitly disabled
  if (config.socialProviders) {
    for (const [name, provider] of Object.entries(config.socialProviders)) {
      // Provider is considered active if: configured AND not explicitly disabled
      if (provider && provider.enabled !== false) {
        // Validate that credentials are provided for active providers
        const hasClientId = !!provider.clientId;
        const hasClientSecret = !!provider.clientSecret;

        if (hasClientId && hasClientSecret) {
          // Both credentials present - provider is fully configured
          continue;
        } else if (hasClientId || hasClientSecret) {
          // Only one credential provided - this is an error
          if (!hasClientId) {
            errors.push(`Social provider '${name}' is missing clientId`);
          }
          if (!hasClientSecret) {
            errors.push(`Social provider '${name}' is missing clientSecret`);
          }
        } else {
          // No credentials provided but provider is configured and not disabled
          // This is likely a configuration mistake - warn the user
          warnings.push(
            `Social provider '${name}' is configured but missing both clientId and clientSecret. ` +
              `Set 'enabled: false' to disable it explicitly, or provide credentials to enable it.`,
          );
        }
      }
    }
  }

  return {
    errors,
    valid: errors.length === 0,
    warnings,
  };
}

/**
 * Validates the secret strength
 * Requirements: min 32 chars, should contain mixed characters
 */
function validateSecret(secret: string): { message?: string; valid: boolean } {
  if (!secret || secret.length < 32) {
    return { message: 'Secret must be at least 32 characters long', valid: false };
  }

  // Check for character diversity (at least 2 of: lowercase, uppercase, numbers, special)
  const hasLowercase = /[a-z]/.test(secret);
  const hasUppercase = /[A-Z]/.test(secret);
  const hasNumbers = /[0-9]/.test(secret);
  const hasSpecial = /[^a-zA-Z0-9]/.test(secret);
  const diversityCount = [hasLowercase, hasUppercase, hasNumbers, hasSpecial].filter(Boolean).length;

  if (diversityCount < 2) {
    return {
      message: 'Secret should contain at least 2 different character types (lowercase, uppercase, numbers, special)',
      valid: true, // Warning only, not an error
    };
  }

  return { valid: true };
}
