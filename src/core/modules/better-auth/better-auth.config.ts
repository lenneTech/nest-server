import { passkey } from '@better-auth/passkey';
import { Logger } from '@nestjs/common';
import { betterAuth, BetterAuthPlugin } from 'better-auth';
import { mongodbAdapter } from 'better-auth/adapters/mongodb';
import { jwt, twoFactor } from 'better-auth/plugins';
import * as crypto from 'crypto';
import * as fs from 'fs';
import * as path from 'path';

import { IBetterAuth } from '../../common/interfaces/server-options.interface';

/**
 * Type for better-auth instance with plugins
 */
export type BetterAuthInstance = ReturnType<typeof betterAuth>;

// ---------------------------------------------------------------------------
// Performance-optimized password hashing using Node.js native crypto.scrypt
//
// Better-Auth's default uses @noble/hashes scrypt which runs on the main
// event loop. Under concurrent load this blocks all requests while hashing.
// Node.js crypto.scrypt() offloads the work to the libuv thread pool,
// allowing the event loop to remain responsive.
//
// Parameters match Better-Auth's defaults exactly:
//   N=16384, r=16, p=1, dkLen=64, 16-byte salt
// ---------------------------------------------------------------------------

const SCRYPT_PARAMS = { maxmem: 128 * 16384 * 16 * 2, N: 16384, p: 1, r: 16 };
const SCRYPT_KEY_LENGTH = 64;

/**
 * Generates a cryptographically secure random secret.
 * Used as fallback when no BETTER_AUTH_SECRET is configured.
 *
 * NOTE: This secret is generated at server startup, meaning:
 * - All existing sessions become invalid on server restart
 * - This is acceptable for development environments
 * - For production, ALWAYS set BETTER_AUTH_SECRET to maintain sessions across restarts
 */
function generateSecureSecret(): string {
  return crypto.randomBytes(32).toString('base64');
}

/**
 * Hash a password using Node.js native crypto.scrypt (libuv thread pool).
 * Output format matches Better-Auth: "salt:hash" (both hex encoded).
 */
async function nativeScryptHash(password: string): Promise<string> {
  const salt = crypto.randomBytes(16).toString('hex');
  const normalized = password.normalize('NFKC');
  const key = await new Promise<Buffer>((resolve, reject) => {
    crypto.scrypt(normalized, salt, SCRYPT_KEY_LENGTH, SCRYPT_PARAMS, (err, derivedKey) => {
      if (err) reject(err);
      else resolve(derivedKey);
    });
  });
  return `${salt}:${key.toString('hex')}`;
}

/**
 * Verify a password against a Better-Auth scrypt hash using Node.js native crypto.scrypt.
 */
async function nativeScryptVerify(data: { hash: string; password: string }): Promise<boolean> {
  const [salt, storedKey] = data.hash.split(':');
  if (!salt || !storedKey) return false;
  const normalized = data.password.normalize('NFKC');
  const key = await new Promise<Buffer>((resolve, reject) => {
    crypto.scrypt(normalized, salt, SCRYPT_KEY_LENGTH, SCRYPT_PARAMS, (err, derivedKey) => {
      if (err) reject(err);
      else resolve(derivedKey);
    });
  });
  return crypto.timingSafeEqual(key, Buffer.from(storedKey, 'hex'));
}

/**
 * Cached auto-generated secret for the current server instance.
 * Generated once at a module load to ensure consistency within a single run.
 */
let cachedAutoGeneratedSecret: null | string = null;

/**
 * Cached project app name for the current server instance.
 * Read once from package.json to avoid repeated file reads.
 */
let cachedProjectAppName: null | string = null;

export interface CreateBetterAuthOptions {
  /**
   * Better-auth configuration from server options
   */
  config: IBetterAuth;

  /**
   * MongoDB database instance
   * Note: Uses 'any' type to handle version incompatibilities between
   * mongoose's bundled mongodb types and the project's mongodb package.
   * At runtime, this is a mongodb.Db instance.
   */
  db: any;

  /**
   * Fallback secrets to try if no betterAuth.secret is configured.
   * The array is iterated and the first valid secret (≥32 chars) is used.
   * If no valid secret is found, an auto-generated secret is used.
   *
   * Typical usage: Pass existing secrets from your config (e.g., jwt.secret)
   * for backwards compatibility.
   *
   * @example
   * ```typescript
   * fallbackSecrets: [config.jwt?.secret, config.jwt?.refresh?.secret]
   * ```
   */
  fallbackSecrets?: (string | undefined)[];

  /**
   * Callback for when email is verified (to sync verifiedAt)
   * Injected from CoreBetterAuthModule
   */
  onEmailVerified?: OnEmailVerifiedCallback;

  /**
   * Callback for sending verification email
   * Injected from CoreBetterAuthModule to use NestJS services
   */
  sendVerificationEmail?: SendVerificationEmailCallback;

  /**
   * Server-level app/frontend URL (from IServerOptions.appUrl).
   * Used for Passkey origin and CORS trustedOrigins.
   */
  serverAppUrl?: string;

  /**
   * Server-level base URL (from IServerOptions.baseUrl).
   * Used as fallback for betterAuth.baseUrl.
   */
  serverBaseUrl?: string;

  /**
   * Server environment (from IServerOptions.env).
   * Used for local environment defaults.
   */
  serverEnv?: string;
}

/**
 * Callback for when email is verified
 * Injected from CoreBetterAuthModule to sync verifiedAt
 */
export type OnEmailVerifiedCallback = (userId: string) => Promise<void>;

/**
 * Options for creating a better-auth instance
 */
/**
 * Callback for sending verification email
 * Injected from CoreBetterAuthModule to use NestJS services
 */
export type SendVerificationEmailCallback = (options: {
  token: string;
  url: string;
  user: { email: string; id: string; name?: null | string };
}) => Promise<void>;

/**
 * Better-Auth field type definition
 * Matches the DBFieldType from better-auth
 */
type BetterAuthFieldType = 'boolean' | 'date' | 'json' | 'number' | 'number[]' | 'string' | 'string[]';

/**
 * Normalized Passkey configuration with required fields
 */
interface NormalizedPasskeyConfig {
  authenticatorAttachment?: 'cross-platform' | 'platform';
  challengeStorage?: 'cookie' | 'database';
  challengeTtlSeconds?: number;
  origin: string;
  residentKey?: 'discouraged' | 'preferred' | 'required';
  rpId: string;
  rpName: string;
  userVerification?: 'discouraged' | 'preferred' | 'required';
  webAuthnChallengeCookie?: string;
}

/**
 * Result of Passkey configuration normalization
 */
interface PasskeyNormalizationResult {
  /**
   * Whether Passkey should be enabled after normalization
   */
  enabled: boolean;

  /**
   * Normalized Passkey configuration (with auto-detected values)
   */
  normalizedConfig: NormalizedPasskeyConfig | null;

  /**
   * Auto-detected trustedOrigins (to be merged with config)
   */
  trustedOrigins: null | string[];

  /**
   * Warnings generated during normalization
   */
  warnings: string[];
}

/**
 * Social provider configuration for better-auth
 */
interface SocialProviderConfig {
  clientId: string;
  clientSecret: string;
}

/**
 * User field configuration type for Better-Auth
 * Matches the DBFieldAttribute structure from better-auth
 */
interface UserFieldConfig {
  defaultValue?: unknown;
  fieldName?: string;
  required?: boolean;
  type: BetterAuthFieldType;
}

/**
 * Validation result for configuration
 */
interface ValidationResult {
  errors: string[];
  resolvedSecret?: string;
  valid: boolean;
  warnings: string[];
}

/**
 * Creates a better-auth instance based on configuration
 *
 * @param options - Configuration options including betterAuth config and MongoDB connection
 * @returns Configured better-auth instance or null if not enabled
 * @throws Error if configuration validation fails
 */
export function createBetterAuthInstance(options: CreateBetterAuthOptions): BetterAuthInstance | null {
  const logger = new Logger('BetterAuthConfig');
  const { config, db, fallbackSecrets, onEmailVerified, sendVerificationEmail, serverEnv } = options;

  // Return null only if better-auth is explicitly disabled
  // BetterAuth is enabled by default (zero-config)
  if (config?.enabled === false) {
    return null;
  }

  // Resolve URLs with auto-detection and local defaults
  const resolvedUrls = resolveUrls(options);

  // Log URL resolution warnings
  for (const warning of resolvedUrls.warnings) {
    logger.log(warning);
  }

  // Normalize Passkey configuration with auto-detection from resolved URLs
  // This must happen BEFORE validation to allow graceful degradation
  // Passkey is now AUTO-ACTIVATED by default (not opt-in)
  const passkeyNormalization = normalizePasskeyConfig(config, { resolvedUrls, serverEnv });

  // Log passkey normalization warnings (info about auto-detection or disabled status)
  for (const warning of passkeyNormalization.warnings) {
    logger.warn(warning);
  }

  // Validate configuration (with fallback secrets for backwards compatibility)
  const validation = validateConfig(config, { fallbackSecrets, passkeyNormalization });

  // Log warnings
  for (const warning of validation.warnings) {
    logger.warn(warning);
  }

  // Throw on validation errors
  if (!validation.valid) {
    throw new Error(`BetterAuth configuration invalid: ${validation.errors.join('; ')}`);
  }

  // Build configuration components (pass normalized passkey config and resolved URLs)
  const plugins = buildPlugins(config, { passkeyNormalization, serverEnv });
  const socialProviders = buildSocialProviders(config);
  const trustedOrigins = buildTrustedOrigins(config, { passkeyNormalization, resolvedUrls });
  const additionalFields = buildUserFields(config);

  // Build email verification configuration
  const emailVerificationConfig = buildEmailVerificationConfig(config, { onEmailVerified, sendVerificationEmail });

  // Build the base Better-Auth configuration
  // Use resolved baseUrl (with local defaults) or fallback
  const basePath = config.basePath || '/iam';
  // Cookie prefix derived from basePath (e.g., '/iam' → 'iam')
  // This ensures Better-Auth looks for cookies like 'iam.session_token' instead of 'better-auth.session_token'
  const cookiePrefix = basePath.replace(/^\//, '').replace(/\//g, '.');

  const betterAuthConfig: Record<string, unknown> = {
    advanced: {
      cookiePrefix,
    },
    basePath,
    baseURL: resolvedUrls.baseUrl || config.baseUrl || 'http://localhost:3000',
    database: mongodbAdapter(db),
    // Enable email/password authentication by default (required by Better-Auth 1.x)
    // Can be disabled by setting config.emailAndPassword.enabled = false
    emailAndPassword: {
      // Defense in Depth: This native Better-Auth flag is the second layer.
      // The first layer is CoreBetterAuthService.ensureSignUpEnabled() which
      // runs in Controller/Resolver BEFORE the BetterAuth API is called and
      // returns a structured LTNS_0026 error. The native flag acts as a safety
      // net in case the custom check is bypassed (e.g., direct API calls).
      disableSignUp: config.emailAndPassword?.disableSignUp === true,
      enabled: config.emailAndPassword?.enabled !== false,
      password: {
        hash: nativeScryptHash,
        verify: nativeScryptVerify,
      },
    },
    plugins,
    secret: validation.resolvedSecret || config.secret,
    socialProviders,
    user: {
      additionalFields,
      modelName: 'users',
    },
  };

  // Add email verification config if enabled
  if (emailVerificationConfig) {
    betterAuthConfig.emailVerification = emailVerificationConfig;
  }

  // Only add trustedOrigins if explicitly configured
  // When undefined, Better-Auth uses its default CORS behavior (allows all origins)
  if (trustedOrigins) {
    betterAuthConfig.trustedOrigins = trustedOrigins;
  }

  // Merge with custom options passthrough
  // This allows projects to configure any Better-Auth option not explicitly defined
  // Deep-merge 'advanced' to preserve cookiePrefix when options.advanced is provided
  let finalConfig: Record<string, unknown>;
  if (config.options) {
    const { advanced: optionsAdvanced, ...restOptions } = config.options as Record<string, unknown>;
    finalConfig = { ...betterAuthConfig, ...restOptions };
    if (optionsAdvanced && typeof optionsAdvanced === 'object') {
      finalConfig.advanced = {
        ...(betterAuthConfig.advanced as Record<string, unknown>),
        ...(optionsAdvanced as Record<string, unknown>),
      };
    }
  } else {
    finalConfig = betterAuthConfig;
  }

  // Create and return the better-auth instance
  // Type assertion needed for maximum flexibility - allows projects to use any Better-Auth option

  return betterAuth(finalConfig as any);
}

/**
 * Formats a package name to a human-readable display name.
 * Converts kebab-case and snake_case to Title Case.
 *
 * @example
 * formatProjectName('my-awesome-app')     // → 'My Awesome App'
 * formatProjectName('@org/my-app')        // → 'My App'
 * formatProjectName('nest_server_starter') // → 'Nest Server Starter'
 */
export function formatProjectName(name: string): string {
  // Remove scope (e.g., '@org/my-app' → 'my-app')
  let formatted = name.replace(/^@[^/]+\//, '');

  // Split by hyphens and underscores, capitalize each word
  formatted = formatted
    .split(/[-_]/)
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
    .join(' ');

  return formatted;
}

/**
 * Builds the email verification configuration for Better-Auth.
 *
 * Email verification is enabled by default unless explicitly disabled.
 * Uses the sendVerificationEmail callback to send emails via NestJS services.
 *
 * @param config - Better-auth configuration
 * @param callbacks - Optional callbacks for email verification lifecycle
 * @returns Email verification config for Better-Auth or null if disabled
 */
function buildEmailVerificationConfig(
  config: IBetterAuth,
  callbacks?: {
    onEmailVerified?: OnEmailVerifiedCallback;
    sendVerificationEmail?: SendVerificationEmailCallback;
  },
): null | Record<string, unknown> {
  const { onEmailVerified, sendVerificationEmail } = callbacks ?? {};
  // Email verification is enabled by default (zero-config):
  // - undefined/null: enabled with defaults
  // - true: enabled with defaults
  // - false: explicitly disabled
  // - { ... }: enabled with custom settings (unless enabled: false)
  const emailVerificationConfig = config.emailVerification;

  if (emailVerificationConfig === false) {
    return null;
  }

  if (typeof emailVerificationConfig === 'object' && emailVerificationConfig.enabled === false) {
    return null;
  }

  // Get configuration values (with defaults)
  const configObj = typeof emailVerificationConfig === 'object' ? emailVerificationConfig : {};
  const expiresIn = configObj.expiresIn ?? 86400; // 24 hours
  const autoSignInAfterVerification = configObj.autoSignInAfterVerification ?? true;

  const result: Record<string, unknown> = {
    autoSignInAfterVerification,
    expiresIn,
    // Also send on sign-in if user is not verified
    sendOnSignIn: true,
    // Send verification email on sign-up by default
    sendOnSignUp: true,
  };

  // Add sendVerificationEmail callback if provided
  if (sendVerificationEmail) {
    result.sendVerificationEmail = async (
      data: { token: string; url: string; user: { email: string; id: string; name?: null | string } },
      _request?: Request,
    ) => {
      // Don't await to prevent timing attacks (as recommended by Better-Auth docs)

      sendVerificationEmail(data);
    };
  }

  // Add callback for when email is verified (to sync verifiedAt)
  if (onEmailVerified) {
    result.afterEmailVerification = async (user: string | { id: string }, _request?: Request) => {
      // Better-Auth passes a user object { id: string } to afterEmailVerification
      const userId = typeof user === 'string' ? user : user.id;
      await onEmailVerified(userId);
    };
  }

  return result;
}

/**
 * Builds the plugins array based on configuration.
 * Merges built-in plugins (jwt, twoFactor, passkey) with custom plugins from config.
 *
 * Plugins accept both boolean and object configuration:
 * - `true` or `{}`: Enable with defaults
 * - `{ option: value }`: Enable with custom settings
 * - `false` or `{ enabled: false }`: Disable
 * - `undefined`: Disabled (default)
 *
 * @param config - Better-auth configuration
 * @param options - Additional options
 * @param options.passkeyNormalization - Normalized passkey configuration from normalizePasskeyConfig()
 * @param options.serverEnv - Server environment for auto-detected app name suffix
 */
function buildPlugins(
  config: IBetterAuth,
  options: { passkeyNormalization: PasskeyNormalizationResult; serverEnv?: string },
): BetterAuthPlugin[] {
  const { passkeyNormalization, serverEnv } = options;
  const plugins: BetterAuthPlugin[] = [];

  // JWT Plugin for API client compatibility
  // JWT is enabled by default unless explicitly disabled (jwt: false or jwt: { enabled: false })
  const jwtExplicitlyDisabled =
    config.jwt === false || (typeof config.jwt === 'object' && config.jwt?.enabled === false);
  if (!jwtExplicitlyDisabled) {
    const jwtConfig = typeof config.jwt === 'object' ? config.jwt : {};
    plugins.push(
      jwt({
        jwt: {
          expirationTime: jwtConfig.expiresIn || '15m',
        },
      }),
    );
  }

  // Two-Factor Authentication Plugin
  // 2FA is enabled by default unless explicitly disabled (twoFactor: false or twoFactor: { enabled: false })
  const twoFactorExplicitlyDisabled =
    config.twoFactor === false || (typeof config.twoFactor === 'object' && config.twoFactor?.enabled === false);
  if (!twoFactorExplicitlyDisabled) {
    const twoFactorConfig = typeof config.twoFactor === 'object' ? config.twoFactor : {};
    plugins.push(
      twoFactor({
        // issuer: Use explicit config, or auto-detect from package.json with environment suffix
        issuer: twoFactorConfig.appName || getProjectAppName(serverEnv),
      }),
    );
  }

  // Passkey/WebAuthn Plugin
  // Uses normalized config from normalizePasskeyConfig() which handles auto-detection
  if (passkeyNormalization.enabled && passkeyNormalization.normalizedConfig) {
    const normalizedPasskey = passkeyNormalization.normalizedConfig;

    // Build passkey options from normalized config
    const passkeyOptions: Record<string, unknown> = {
      origin: normalizedPasskey.origin,
      rpID: normalizedPasskey.rpId,
      rpName: normalizedPasskey.rpName,
    };

    // Add optional WebAuthn configuration if specified
    if (normalizedPasskey.authenticatorAttachment) {
      passkeyOptions.authenticatorAttachment = normalizedPasskey.authenticatorAttachment;
    }
    if (normalizedPasskey.residentKey) {
      passkeyOptions.residentKey = normalizedPasskey.residentKey;
    }
    if (normalizedPasskey.userVerification) {
      passkeyOptions.userVerification = normalizedPasskey.userVerification;
    }
    if (normalizedPasskey.webAuthnChallengeCookie) {
      passkeyOptions.webAuthnChallengeCookie = normalizedPasskey.webAuthnChallengeCookie;
    }

    plugins.push(passkey(passkeyOptions));
  }

  // Merge custom plugins from configuration
  // This allows projects to add any Better-Auth plugin without modifying this package
  if (config.plugins?.length) {
    plugins.push(...(config.plugins as BetterAuthPlugin[]));
  }

  return plugins;
}

/**
 * Builds the social providers configuration object dynamically.
 * Iterates over all configured providers and includes those that are enabled
 * with valid clientId and clientSecret.
 */
function buildSocialProviders(config: IBetterAuth): Record<string, SocialProviderConfig> {
  const socialProvidersConfig: Record<string, SocialProviderConfig> = {};

  // Iterate over all configured social providers dynamically
  // A provider is enabled by default if it has credentials configured
  // It can be explicitly disabled by setting enabled: false
  if (config.socialProviders) {
    for (const [name, provider] of Object.entries(config.socialProviders)) {
      if (provider?.clientId && provider?.clientSecret && provider?.enabled !== false) {
        socialProvidersConfig[name] = {
          clientId: provider.clientId,
          clientSecret: provider.clientSecret,
        };
      }
    }
  }

  return socialProvidersConfig;
}

/**
 * Builds the trusted origins array for CORS configuration.
 *
 * Behavior:
 * - If trustedOrigins is explicitly configured → use those origins
 * - If Passkey is enabled → use trustedOrigins from normalizePasskeyConfig()
 * - Fallback to resolved appUrl
 * - Otherwise → return undefined (allows all origins via Better-Auth's default)
 *
 * @param config - Better-auth configuration
 * @param options - Passkey normalization and resolved URLs context
 */
function buildTrustedOrigins(
  config: IBetterAuth,
  options: {
    passkeyNormalization: PasskeyNormalizationResult;
    resolvedUrls: ResolvedUrls;
  },
): string[] | undefined {
  const { passkeyNormalization, resolvedUrls } = options;
  // If trustedOrigins is explicitly configured, use it
  if (config.trustedOrigins?.length) {
    return config.trustedOrigins;
  }

  // If Passkey is enabled, use the trustedOrigins from normalization
  if (passkeyNormalization.enabled && passkeyNormalization.trustedOrigins?.length) {
    return passkeyNormalization.trustedOrigins;
  }

  // Fallback to resolved appUrl (for CORS even without Passkey)
  if (resolvedUrls.appUrl) {
    return [resolvedUrls.appUrl];
  }

  // Otherwise, let Better-Auth handle CORS with its default behavior
  // This allows all origins for requests without credentials
  return undefined;
}

/**
 * Builds the user additional fields configuration.
 * Merges core fields (firstName, lastName, etc.) with custom fields from config.
 * Custom fields override core fields if they have the same key.
 */
function buildUserFields(config: IBetterAuth): Record<string, UserFieldConfig> {
  // Core fields required for nest-server functionality
  const coreFields: Record<string, UserFieldConfig> = {
    firstName: {
      defaultValue: null,
      fieldName: 'firstName',
      type: 'string',
    },
    iamId: {
      defaultValue: null,
      fieldName: 'iamId',
      type: 'string',
    },
    lastName: {
      defaultValue: null,
      fieldName: 'lastName',
      type: 'string',
    },
    roles: {
      defaultValue: [],
      fieldName: 'roles',
      type: 'string[]',
    },
    // Track when terms and privacy policy were accepted (for sign-up checks)
    termsAndPrivacyAcceptedAt: {
      defaultValue: null,
      fieldName: 'termsAndPrivacyAcceptedAt',
      type: 'date',
    },
    twoFactorEnabled: {
      defaultValue: false,
      fieldName: 'twoFactorEnabled',
      type: 'boolean',
    },
    verified: {
      defaultValue: false,
      fieldName: 'verified',
      type: 'boolean',
    },
    // Track when email was verified (synced from Better-Auth)
    verifiedAt: {
      defaultValue: null,
      fieldName: 'verifiedAt',
      type: 'date',
    },
  };

  // Merge with custom additional fields from configuration
  // Custom fields can override core fields or add new ones
  if (config.additionalUserFields) {
    for (const [key, field] of Object.entries(config.additionalUserFields)) {
      coreFields[key] = {
        defaultValue: field.defaultValue,
        fieldName: field.fieldName || key,
        required: field.required,
        type: field.type,
      };
    }
  }

  return coreFields;
}

/**
 * Formats the environment name as a suffix.
 * Only adds suffix for development/test environments.
 *
 * @example
 * formatEnvSuffix('local')      // → '(Local)'
 * formatEnvSuffix('development') // → '(Development)'
 * formatEnvSuffix('test')       // → '(Test)'
 * formatEnvSuffix('production') // → '' (no suffix for production)
 * formatEnvSuffix(undefined)    // → ''
 */
function formatEnvSuffix(env?: string): string {
  if (!env) return '';

  // Don't add suffix for production
  if (env === 'production' || env === 'prod') return '';

  // Capitalize first letter
  const formatted = env.charAt(0).toUpperCase() + env.slice(1).toLowerCase();
  return `(${formatted})`;
}

/**
 * Gets or generates the fallback secret for development.
 * The secret is cached to ensure consistency during the server's lifetime.
 */
function getAutoGeneratedSecret(): string {
  if (!cachedAutoGeneratedSecret) {
    cachedAutoGeneratedSecret = generateSecureSecret();
  }
  return cachedAutoGeneratedSecret;
}

/**
 * Gets the project's app name from package.json.
 *
 * This function reads the `name` field from the project's package.json
 * and formats it for display (converts a kebab-case to Title Case).
 *
 * Used as default for:
 * - `betterAuth.passkey.rpName` (displayed in browser Passkey prompts)
 * - `betterAuth.twoFactor.appName` (displayed in authenticator apps)
 *
 * @param serverEnv - Optional server environment to append as suffix (e.g., 'local' → '(Local)')
 * @returns The formatted project name, or 'Nest Server' as fallback
 *
 * @example
 * // package.json: { "name": "my-awesome-app" }
 * getProjectAppName()           // → 'My Awesome App'
 * getProjectAppName('local')    // → 'My Awesome App (Local)'
 * getProjectAppName('test')     // → 'My Awesome App (Test)'
 */
function getProjectAppName(serverEnv?: string): string {
  // Return cached value if available (without env suffix, will be added after)
  if (cachedProjectAppName === null) {
    cachedProjectAppName = readProjectNameFromPackageJson();
  }

  // Add environment suffix for non-production environments
  // This helps developers distinguish Passkeys when running multiple projects locally
  const envSuffix = formatEnvSuffix(serverEnv);
  return envSuffix ? `${cachedProjectAppName} ${envSuffix}` : cachedProjectAppName;
}

/**
 * Checks if a secret has valid minimum length (32 characters)
 */
function isValidSecretLength(secret: string): boolean {
  return secret && secret.length >= 32;
}

/**
 * Validates a URL string
 */
function isValidUrl(url: string): boolean {
  try {
    new URL(url);
    return true;
  } catch {
    return false;
  }
}

/**
 * Reads the project name from package.json in the current working directory.
 * Falls back to 'Nest Server' if package.json cannot be read or has no name.
 */
function readProjectNameFromPackageJson(): string {
  const fallback = 'Nest Server';

  try {
    const packageJsonPath = path.join(process.cwd(), 'package.json');
    const packageJsonContent = fs.readFileSync(packageJsonPath, 'utf-8');
    const packageJson = JSON.parse(packageJsonContent);

    if (packageJson.name && typeof packageJson.name === 'string') {
      return formatProjectName(packageJson.name);
    }
  } catch {
    // Ignore errors - use fallback
  }

  return fallback;
}

/**
 * Default URLs for local/test environments (local, ci, e2e)
 * These environments typically run on localhost and don't have a deployed domain.
 */
const LOCALHOST_DEFAULTS = {
  API_URL: 'http://localhost:3000',
  APP_URL: 'http://localhost:3001',
};

/**
 * Environments that use localhost defaults for URLs.
 * These are typically development/test environments without deployed domains.
 */
const LOCALHOST_ENVS = ['local', 'ci', 'e2e'];

/**
 * Resolves the effective URLs for BetterAuth configuration.
 *
 * Resolution priority:
 * 1. Explicit betterAuth config values
 * 2. Server-level URLs (IServerOptions.baseUrl, IServerOptions.appUrl)
 * 3. Auto-derived values (appUrl from baseUrl)
 * 4. Local environment defaults (when env: 'local')
 *
 * @param options - CreateBetterAuthOptions containing config and server URLs
 * @returns Resolved URLs with warnings for logging
 */
interface ResolvedUrls {
  appUrl: string | undefined;
  baseUrl: string | undefined;
  rpId: string | undefined;
  warnings: string[];
}

/**
 * Derives appUrl from baseUrl by removing 'api.' prefix from subdomain.
 *
 * Examples:
 * - 'https://api.example.com' → 'https://example.com'
 * - 'https://api.dev.example.com' → 'https://dev.example.com'
 * - 'https://example.com' → 'https://example.com' (unchanged)
 * - 'http://localhost:3000' → 'http://localhost:3000' (unchanged)
 *
 * @param baseUrl - The API base URL
 * @returns Derived app URL or the original URL if no 'api.' prefix
 */
function deriveAppUrlFromBaseUrl(baseUrl: string): string {
  try {
    const url = new URL(baseUrl);
    const hostname = url.hostname;

    // Check if hostname starts with 'api.'
    if (hostname.startsWith('api.')) {
      // Remove 'api.' prefix
      url.hostname = hostname.substring(4);
      return url.origin;
    }

    // Return original URL if no 'api.' prefix
    return url.origin;
  } catch {
    return baseUrl;
  }
}

/**
 * Extracts the root domain from a URL for use as Passkey rpId.
 *
 * For localhost: Returns 'localhost' (not 'localhost:3000')
 * For domains: Returns the registrable domain (e.g., 'example.com')
 *
 * Examples:
 * - 'https://api.example.com' → 'example.com'
 * - 'https://app.dev.example.com' → 'example.com'
 * - 'http://localhost:3000' → 'localhost'
 * - 'https://example.com' → 'example.com'
 *
 * @param url - The URL to extract rpId from
 * @returns The root domain suitable for Passkey rpId
 */
function extractRpIdFromUrl(url: string): string {
  try {
    const parsedUrl = new URL(url);
    const hostname = parsedUrl.hostname;

    // localhost is a special case
    if (hostname === 'localhost' || hostname === '127.0.0.1') {
      return 'localhost';
    }

    // For regular domains, extract the registrable domain
    // This is a simplified approach - for complex TLDs like .co.uk, a library would be better
    const parts = hostname.split('.');

    // If it's just a simple domain (example.com), return it
    if (parts.length <= 2) {
      return hostname;
    }

    // For subdomains, return the last two parts (example.com from api.example.com)
    // Note: This doesn't handle .co.uk style TLDs correctly, but works for common cases
    return parts.slice(-2).join('.');
  } catch {
    return 'localhost';
  }
}

/**
 * Normalizes Passkey configuration with auto-detection from resolved URLs.
 *
 * **AUTO-ACTIVATION:** Passkey is enabled by default when BetterAuth is active.
 * It is only disabled when:
 * 1. Explicitly disabled: `passkey: false` or `passkey: { enabled: false }`
 * 2. Required URLs cannot be resolved (Graceful Degradation)
 *
 * Auto-Detection Logic (using resolvedUrls from resolveUrls()):
 * - `rpId`: from passkey.rpId > resolvedUrls.rpId (derived from appUrl)
 * - `origin`: from passkey.origin > resolvedUrls.appUrl
 * - `trustedOrigins`: from config.trustedOrigins > [resolvedUrls.appUrl]
 *
 * @param config - Better-auth configuration
 * @param options - Additional options
 * @param options.resolvedUrls - Resolved URLs from resolveUrls()
 * @param options.serverEnv - Server environment for auto-detected app name suffix
 * @returns Normalization result with enabled status, config, and warnings
 */
function normalizePasskeyConfig(
  config: IBetterAuth,
  options: { resolvedUrls: ResolvedUrls; serverEnv?: string },
): PasskeyNormalizationResult {
  const { resolvedUrls, serverEnv } = options;
  const warnings: string[] = [];

  // Check if Passkey is explicitly DISABLED
  // passkey: false OR passkey: { enabled: false }
  const isExplicitlyDisabled =
    config.passkey === false || (typeof config.passkey === 'object' && config.passkey?.enabled === false);

  if (isExplicitlyDisabled) {
    return { enabled: false, normalizedConfig: null, trustedOrigins: null, warnings };
  }

  // Get the raw passkey config (if object)
  const rawConfig = typeof config.passkey === 'object' ? config.passkey : {};

  // Resolve values: explicit config > resolved URLs
  const finalRpId = rawConfig.rpId || resolvedUrls.rpId;
  const finalOrigin = rawConfig.origin || resolvedUrls.appUrl;
  const finalTrustedOrigins = config.trustedOrigins?.length
    ? config.trustedOrigins
    : resolvedUrls.appUrl
      ? [resolvedUrls.appUrl]
      : undefined;

  // Check if we have all required values for Passkey
  const hasRequiredConfig = finalRpId && finalOrigin && finalTrustedOrigins?.length;

  if (!hasRequiredConfig) {
    // Graceful Degradation: Disable Passkey with warning
    const missingFields: string[] = [];
    if (!finalRpId) missingFields.push('rpId');
    if (!finalOrigin) missingFields.push('origin');
    if (!finalTrustedOrigins?.length) missingFields.push('trustedOrigins');

    warnings.push(
      `⚠️ PASSKEY DISABLED: Cannot auto-detect required values (${missingFields.join(', ')}). ` +
        'To enable Passkey, set baseUrl in your config or configure passkey values explicitly.',
    );
    warnings.push(
      'Fix options:\n' +
        '  1. Set baseUrl: "https://api.example.com" → auto-detects appUrl, rpId, origin\n' +
        '  2. Set env: "local" → uses localhost:3000 (API) and localhost:3001 (App) defaults\n' +
        '  3. Disable Passkey explicitly: passkey: false (no warning)',
    );

    return { enabled: false, normalizedConfig: null, trustedOrigins: null, warnings };
  }

  // Log auto-detection info
  if (!rawConfig.rpId && resolvedUrls.rpId) {
    warnings.push(`PASSKEY: Using rpId="${finalRpId}" (auto-detected from appUrl)`);
  }
  if (!rawConfig.origin && resolvedUrls.appUrl) {
    warnings.push(`PASSKEY: Using origin="${finalOrigin}" (= appUrl)`);
  }
  if (!config.trustedOrigins?.length && resolvedUrls.appUrl) {
    warnings.push(`PASSKEY: Using trustedOrigins=${JSON.stringify(finalTrustedOrigins)} (= [appUrl])`);
  }

  // Build normalized config
  // rpName: Use explicit config, or auto-detect from package.json with environment suffix
  const normalizedConfig: NormalizedPasskeyConfig = {
    origin: finalOrigin,
    rpId: finalRpId,
    rpName: rawConfig.rpName || getProjectAppName(serverEnv),
  };

  // Copy optional fields from explicit config
  if (rawConfig.authenticatorAttachment) {
    normalizedConfig.authenticatorAttachment = rawConfig.authenticatorAttachment;
  }
  if (rawConfig.challengeStorage) {
    normalizedConfig.challengeStorage = rawConfig.challengeStorage;
  }
  if (rawConfig.challengeTtlSeconds) {
    normalizedConfig.challengeTtlSeconds = rawConfig.challengeTtlSeconds;
  }
  if (rawConfig.residentKey) {
    normalizedConfig.residentKey = rawConfig.residentKey;
  }
  if (rawConfig.userVerification) {
    normalizedConfig.userVerification = rawConfig.userVerification;
  }
  if (rawConfig.webAuthnChallengeCookie) {
    normalizedConfig.webAuthnChallengeCookie = rawConfig.webAuthnChallengeCookie;
  }

  return {
    enabled: true,
    normalizedConfig,
    trustedOrigins: finalTrustedOrigins,
    warnings,
  };
}

function resolveUrls(options: CreateBetterAuthOptions): ResolvedUrls {
  const { config, serverAppUrl, serverBaseUrl, serverEnv } = options;
  const warnings: string[] = [];
  const usesLocalhostDefaults = LOCALHOST_ENVS.includes(serverEnv || '');

  // Step 1: Resolve baseUrl
  // Priority: betterAuth.baseUrl > serverBaseUrl > localhost default (for local/ci/e2e)
  let baseUrl = config.baseUrl || serverBaseUrl;
  if (!baseUrl && usesLocalhostDefaults) {
    baseUrl = LOCALHOST_DEFAULTS.API_URL;
    warnings.push(`URL: Using localhost default baseUrl="${baseUrl}" (env: '${serverEnv}')`);
  }

  // Step 2: Resolve appUrl
  // Priority: serverAppUrl > localhost default (when baseUrl is localhost) > derived from baseUrl
  let appUrl = serverAppUrl;

  // For localhost environments with localhost baseUrl, use localhost app default
  // This handles the common case where API runs on :3000 and App on :3001
  const isBaseUrlLocalhost = baseUrl && (baseUrl.includes('localhost') || baseUrl.includes('127.0.0.1'));
  if (!appUrl && usesLocalhostDefaults && isBaseUrlLocalhost) {
    appUrl = LOCALHOST_DEFAULTS.APP_URL;
    warnings.push(`URL: Using localhost default appUrl="${appUrl}" (env: '${serverEnv}')`);
  }

  // For non-localhost environments, try to derive appUrl from baseUrl
  if (!appUrl && baseUrl) {
    appUrl = deriveAppUrlFromBaseUrl(baseUrl);
    if (appUrl !== baseUrl) {
      warnings.push(`URL: Auto-derived appUrl="${appUrl}" from baseUrl="${baseUrl}"`);
    }
  }

  // Step 3: Resolve rpId from appUrl (not baseUrl!)
  // rpId should be the domain where the user authenticates (app domain)
  let rpId: string | undefined;
  if (appUrl) {
    rpId = extractRpIdFromUrl(appUrl);
  }

  return { appUrl, baseUrl, rpId, warnings };
}

/**
 * Validates the better-auth configuration and applies fallback secret if needed.
 * Mutates config.secret if fallback is applied.
 *
 * Secret resolution order:
 * 1. betterAuth.secret (if configured and valid)
 * 2. First valid secret from fallbackSecrets array (≥32 chars)
 * 3. Auto-generated secure secret (with warning)
 *
 * @param config - Better-auth configuration
 * @param options - Optional validation context (fallback secrets, passkey normalization)
 */
function validateConfig(
  config: IBetterAuth,
  options?: {
    fallbackSecrets?: (string | undefined)[];
    passkeyNormalization?: PasskeyNormalizationResult;
  },
): ValidationResult {
  const { fallbackSecrets, passkeyNormalization } = options ?? {};
  const errors: string[] = [];
  const warnings: string[] = [];

  // Track secret source for appropriate messaging
  let secretSource: 'auto-generated' | 'explicit' | 'fallback' = 'explicit';
  let resolvedSecret = config.secret;

  // Resolve secret with fallback chain (without mutating the config object)
  if (!resolvedSecret || resolvedSecret.trim() === '') {
    // Try fallback secrets in order
    const validFallback = fallbackSecrets?.find((secret) => secret && isValidSecretLength(secret));

    if (validFallback) {
      resolvedSecret = validFallback;
      secretSource = 'fallback';
    } else {
      // Last resort: auto-generate
      resolvedSecret = getAutoGeneratedSecret();
      secretSource = 'auto-generated';
    }
  }

  // Validate the resolved secret
  const secretValidation = validateSecret(resolvedSecret);
  if (!secretValidation.valid) {
    errors.push(secretValidation.message!);
  } else if (secretValidation.message) {
    warnings.push(secretValidation.message);
  }

  // Log information about secret source
  switch (secretSource) {
    case 'auto-generated':
      warnings.push('BETTER_AUTH: No secret configured - using auto-generated secret.');
      warnings.push('CONSEQUENCE: All user sessions will be invalidated on server restart!');
      warnings.push(
        'FOR PRODUCTION: Set betterAuth.secret in config or provide a valid fallback secret (min 32 chars).',
      );
      warnings.push("Generate with: node -e \"console.log(require('crypto').randomBytes(32).toString('base64'))\"");
      break;
    case 'fallback':
      warnings.push(
        'BETTER_AUTH: Using fallback secret (backwards compatible). Consider setting betterAuth.secret explicitly.',
      );
      break;
    // 'explicit' - no warning needed, explicitly configured
  }

  // Validate baseUrl
  if (config.baseUrl && !isValidUrl(config.baseUrl)) {
    errors.push(`Invalid baseUrl format: ${config.baseUrl}`);
  }

  // Validate trustedOrigins (if explicitly configured)
  if (config.trustedOrigins) {
    for (const origin of config.trustedOrigins) {
      if (!isValidUrl(origin)) {
        errors.push(`Invalid trustedOrigin format: ${origin}`);
      }
    }
  }

  // Validate auto-detected trustedOrigins from passkey normalization
  if (passkeyNormalization?.trustedOrigins) {
    for (const origin of passkeyNormalization.trustedOrigins) {
      if (!isValidUrl(origin)) {
        errors.push(`Invalid auto-detected trustedOrigin format: ${origin}`);
      }
    }
  }

  // Validate passkey origin (only if passkey is enabled after normalization)
  if (passkeyNormalization?.enabled && passkeyNormalization.normalizedConfig) {
    const normalizedOrigin = passkeyNormalization.normalizedConfig.origin;
    if (!isValidUrl(normalizedOrigin)) {
      errors.push(`Invalid passkey origin format: ${normalizedOrigin}`);
    }
  }

  // Validate social providers dynamically
  // Providers are enabled by default unless explicitly disabled (enabled: false)
  // We only validate credentials for providers that are not explicitly disabled
  if (config.socialProviders) {
    for (const [name, provider] of Object.entries(config.socialProviders)) {
      // Provider is considered active if: configured AND not explicitly disabled
      if (provider && provider.enabled !== false) {
        // Validate that credentials are provided for active providers
        const hasClientId = !!provider.clientId;
        const hasClientSecret = !!provider.clientSecret;

        if (hasClientId && hasClientSecret) {
          // Both credentials present - provider is fully configured
          continue;
        } else if (hasClientId || hasClientSecret) {
          // Only one credential provided - this is an error
          if (!hasClientId) {
            errors.push(`Social provider '${name}' is missing clientId`);
          }
          if (!hasClientSecret) {
            errors.push(`Social provider '${name}' is missing clientSecret`);
          }
        } else {
          // No credentials provided, but the provider is configured and not disabled
          // This is likely a configuration mistake - warn the user
          warnings.push(
            `Social provider '${name}' is configured but missing both clientId and clientSecret. ` +
              `Set 'enabled: false' to disable it explicitly, or provide credentials to enable it.`,
          );
        }
      }
    }
  }

  return {
    errors,
    resolvedSecret,
    valid: errors.length === 0,
    warnings,
  };
}

/**
 * Validates the secret strength
 * Requirements: min 32 chars, should contain mixed characters
 */
function validateSecret(secret: string): { message?: string; valid: boolean } {
  if (!secret || secret.length < 32) {
    return { message: 'Secret must be at least 32 characters long', valid: false };
  }

  // Check for character diversity (at least 2 of: lowercase, uppercase, numbers, special)
  const hasLowercase = /[a-z]/.test(secret);
  const hasUppercase = /[A-Z]/.test(secret);
  const hasNumbers = /[0-9]/.test(secret);
  const hasSpecial = /[^a-zA-Z0-9]/.test(secret);
  const diversityCount = [hasLowercase, hasUppercase, hasNumbers, hasSpecial].filter(Boolean).length;

  if (diversityCount < 2) {
    return {
      message: 'Secret should contain at least 2 different character types (lowercase, uppercase, numbers, special)',
      valid: true, // Warning only, not an error
    };
  }

  return { valid: true };
}
